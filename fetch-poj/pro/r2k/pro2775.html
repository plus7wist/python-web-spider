<h2 align="center">The Number of the Same BST</h2></div>
<div class="plm"><table align="center"><tr><td><b>Time Limit:</b> 1000MS</td><td width="10px"></td><td><b>Memory Limit:</b> 65536K</td></tr><tr><td><b>Total Submissions:</b> 907</td><td width="10px"></td><td><b>Accepted:</b> 370</td></table></div><h3>Description</h3><div class="ptx" lang="en-US">Many people knows binary search tree. The keys in a binary search tree are always stored in such a way as to satisfy the BST property:<br><br>Let x be a node in a binary search tree. If y is a node in the left subtree of x, then key[y] <= key[x]. If y is a node in the right subtree of x, then key[y] > key[x].<br><br>For example,<br><center><img src=images\2775_1.gif></center><br>It is a binary search tree. And it can be built by inserting the elements of vector A <12, 6, 3, 18, 20, 10, 4, 17, 20> sequentially. But it can also be built by the vector B <12, 18, 17, 6, 20, 3, 10, 4, 20>.<br><br>Now given a vector X, then you may get a binary search tree from X. Your job is to calculate how many different vectors can build the same binary search tree. To make it easy, you should just output the number of different vectors mod 9901.<br></div><h3>Input</h3><div class="ptx" lang="en-US">Input consists of several cases. Each case starts with a line containing one positive integer n, which is the length of test vector. The integer n is less than 100. Following this there will be n positive integers, which are less then 10000, on the next line. The input will end with a case starting with n = 0. This case should not be processed.</div><h3>Output</h3><div class="ptx" lang="en-US">For each test case, print a line with a single integer, which is the number of different vectors mod 9901.</div><h3>Sample Input</h3><pre class="sio">3
2 1 3
9
5 6 3 18 20 10 4 17 20
0
</pre><h3>Sample Output</h3><pre class="sio">2
168
</pre><h3>Source</h3><div class="ptx" lang="en-US"><a>POJ Monthly--2006.03.26</a>,newton88518</div></td></tr></table>
