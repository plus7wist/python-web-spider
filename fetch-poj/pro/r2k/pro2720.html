<h2 align="center">Last Digits</h2></div>
<div class="plm"><table align="center"><tr><td><b>Time Limit:</b> 1000MS</td><td width="10px"></td><td><b>Memory Limit:</b> 65536K</td></tr><tr><td><b>Total Submissions:</b> 2145</td><td width="10px"></td><td><b>Accepted:</b> 450</td></table></div><h3>Description</h3><div class="ptx" lang="en-US">Exponentiation of one integer by another often produces very large results. In this problem, we will compute a function based on repeated exponentiation, but output only the last n digits of the result. Doing this efficiently requires careful thought about how to avoid computing the full answer. <br><br>Given integers b, n, and i, we define the function f(x) recursively by f(x) = b<sup>f(x-1)</sup> if x > 0, and f(0)=1. Your job is to efficiently compute the last n decimal digits of f(i). <br></div><h3>Input</h3><div class="ptx" lang="en-US">The input consists of a number of test cases. Each test case starts with the integer b (1 <= b <= 100) called the base. On the next line is the integer i (1 <= i <= 100) called the iteration count. And finally, the last line contains the number n (1 <= n <= 7), which is the number of decimal digits to output. The input is terminated when b = 0. </div><h3>Output</h3><div class="ptx" lang="en-US">For each test case, print on one line the last n digits of f(i) for the base b specified. If the result has fewer than n digits, pad the result with zeroes on the left so that there are exactly n digits. </div><h3>Sample Input</h3><pre class="sio">2
4
7
10
10
6
3
10
7
0
</pre><h3>Sample Output</h3><pre class="sio">0065536
000000
4195387
</pre><h3>Source</h3><div class="ptx" lang="en-US"><a>Rocky Mountain 2005</a></div></td></tr></table>
