<h2 align="center">Zip</h2></div>
<div class="plm"><table align="center"><tr><td><b>Time Limit:</b> 1000MS</td><td width="10px"></td><td><b>Memory Limit:</b> 10000K</td></tr><tr><td><b>Total Submissions:</b> 977</td><td width="10px"></td><td><b>Accepted:</b> 205</td></table></div><h3>Description</h3><div class="ptx" lang="en-US">People are pursuing enhancing the file compression rate for long time. Recently, someone proposed an algorithm, which only rearrange the file, not compressing file. But we can achieve much more compressoin rate than ever before after adapting the file using this algorithm.<br>We define a string's head as its first character, and tail as its last character.<br>Now I'll show you how this algorithm works: there is a string ,said S, consists of n characters. First we construct n strings from it, the i'th string is obtained by moving the head of the i-1'th string to its tail. Then we sort the n strings by their heads, if two strings' heads are equal, sort them by the two heads' position in S.    After sort, we can obtain a new string S'  consists of the tails in the sorting result strings.   <br>It's obvious that  the length of S'  is also n, and it contains all the characters in S. At last, you must output S' and the position of the first character of S in S',an integer,p.<br>For example:<br>S: example<br>1.       construct n strings<br>example<br>xamplee<br>ampleex<br>mpleexa<br>pleexam<br>leexamp<br>eexampl<br>2.     Sort these string as mentioned<br>ampleex<br>example<br>eexampl<br>leexamp<br>mpleexa<br>pleexam<br>xamplee<br>3.       Construct S' by the tails of sorting results and output<br><pre>xelpame               S'<br>7                     p</pre><br>Since the occurrence of the same English words is high-frequent, we can achieve high compression rate of S'. Although this algorithm utilizes English word's occurrence characteristics, people also find this algorithm does well for most filetype's compression.<br>You task is simple, it's not compressing the file. You should construct S' from S and reconstruct S from given S' and p.<br></div><h3>Input</h3><div class="ptx" lang="en-US">The input contains only one case, the first line is a char  C indicating which job you should do.<br><br>When C is 'A' , that means you should construct S' from S. The next line is an integer n(1 <=n<=10000), the length of S. The third line is the string S.<br><br>When C is 'B' , that means you should reconstruct S from S'. The next line is an integer n(1 <=n<=10000), the length of S'. The next line is the string S', the fourth line is an integer p. <br></div><h3>Output</h3><div class="ptx" lang="en-US">When C is 'A' , You should output two lines, the first of which is S' and second is p.<br><br>When C is 'B' ,You should output just one line containing the string S.<br></div><h3>Sample Input</h3><pre class="sio"><font color=blue size=5>Sample input 1:</font>
A
7
example
<font color=blue size=5>Sample input 2:</font>
B
7
xelpame
7
</pre><h3>Sample Output</h3><pre class="sio"><font color=blue size=5>Sample output 1:</font>
xelpame
7
<font color=blue size=5>Sample output 2:</font>
example</pre><h3>Source</h3><div class="ptx" lang="en-US"><a>浙江OI 2001</a></div></td></tr></table>
